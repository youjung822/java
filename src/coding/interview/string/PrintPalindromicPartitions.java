package coding.interview.string;

//import java.util.Arrays;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;

public class PrintPalindromicPartitions {
   /* Given a string, print all possible palindromic partitions.
     cf: A palindrome is a word, number, phrase, or other sequence
      of characters which reads the same backward as forward,
      such as madam or racecar or the number 10801.
    Example:
    Input: nitin
    Output: n i t i n
            n iti n
            nitin
     Input: geeks
     Output: g e e k s
             g ee k s
    */

   //Driver program
   public static void main(String[] args){
        String input = "geek";
        System.out.println("All possible palindrome partions for " +input+" are ");
        allPalPartitions(input);
    }

    //Function to print all possible palindromic partitions of str.
    //It mainly creates vectors and calls allPalPartUtil().
    private static void allPalPartitions(String input){
       int n = input.length();
       //To store all palindromic partitions
        ArrayList<ArrayList<String>> allPart = new ArrayList<>();

        //To store current palindromic partition
        Deque<String> currPart = new LinkedList<String>();

        //Call recursive function to generate all partition and store in allPart
        allPalPartitionsUtil(allPart,currPart,0,n,input);

        //Print all partitions generated by above call
        for(int i = 0; i< allPart.size(); i++){
            for(int j = 0; j < allPart.get(i).size(); j++){
                System.out.print(allPart.get(i).get(j) + " ");
            }
            System.out.println();
        }
    }
    //Recursive function to find all palindromic partitions of input[start..n-1] allPart -->A
    //ArrayList of Deque of strings. Every Deque inside it stores a partition currPart --> A
    //Deque of strings to store current partition
    private static void allPalPartitionsUtil(ArrayList<ArrayList<String>> allPart,
                                             Deque<String> currPart, int start, int n, String input){
       //If 'start' has reached len
       if(start>=n){
           allPart.add(new ArrayList<>(currPart));
           return;
       }
       //Pick all possible ending points for substrings
        for (int i = start; i <n; i++){
            //if substring str[start..i] is palindrome
            if(isPalindrome(input, start,i)){
                //Add the substring to result
                currPart.addLast(input.substring(start, i+1));
                //recur for remaining substring
                allPalPartitionsUtil(allPart,currPart, i+1, n, input);

                //Remove substring str[start..i] from current
                //partition
                currPart.removeLast();
            }
        }

    }

    private static boolean isPalindrome(String input, int start, int i){
       while(start<i){
           if(input.charAt(start++)!=input.charAt(i--)) return false;
       }
       return true;
    }


   /*My answer/////////////////////////////////////////
    public static void main(String[] arg){
        String strOrig = "nitin";
        char[] arrOrig = strOrig.toCharArray();
        //key
        for(int i =0; i <strOrig.length();){
            for(int j=i+1; j<strOrig.length()+1; j++){
                char[] arrPortion = new char[j-i];
                System.arraycopy(arrOrig,i,arrPortion,0,j-i);//**Remember;
                char[] arrOpposite= reverseArray(arrPortion);
               // System.out.println("i: "+i+" j: "+j+ " strPortion: "+String.valueOf(arrPortion)+" strOpsite: "+ String.valueOf(arrOpposite));
                if(String.valueOf(arrPortion).equals(String.valueOf(arrOpposite))){
                    System.out.println(String.valueOf(arrPortion));
                }
            }
            i++;
        }

    }
    public static char[] reverseArray(char[] orig){
        char[] reversed = new char[orig.length];
        for(int i = 0; i < orig.length; i++){
            reversed[i] = orig[orig.length-1-i];
        }
        return reversed;
    }
     *///////////////////////////////////////////////////
}
